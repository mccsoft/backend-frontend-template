const resultTypesByQueryKey: Record<string, () => { init(data: any): void }> = {};

/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export * as ProductClient from './api-client/ProductClient';

export * as ProductQuery from './api-client/ProductQuery';



export * as SignUrlClient from './api-client/SignUrlClient';

    create(dto: CreateProductDto , cancelToken?: CancelToken | undefined): Promise<ProductDto> {
        let url_ = this.baseUrl + "/api/products";
        url_ = url_.replace(/[?&]$/, "");


        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

export * as TestDataClient from './api-client/TestDataClient';

export * as TestDataQuery from './api-client/TestDataQuery';



    delete(id?: number | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/products?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };



        } else if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param search (optional) 
     * @param productType (optional) 
     * @param lastStockUpdatedAt (optional) 
     * @param offset (optional) Offset of list.
     * @param limit (optional) Number of requested records.
     * @param sortBy (optional) Field name for sorting in DB.
     * @param sortOrder (optional) Sort direction. Ascending or Descending.
     */
    search(search?: string | null | undefined, productType?: ProductType | null | undefined, lastStockUpdatedAt?: Date | null | undefined, offset?: number | null | undefined, limit?: number | null | undefined, sortBy?: string | null | undefined, sortOrder?: SortOrder | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultOfProductListItemDto> {
        let url_ = this.baseUrl + "/api/products?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (productType !== undefined && productType !== null)
            url_ += "ProductType=" + encodeURIComponent("" + productType) + "&";
        if (lastStockUpdatedAt !== undefined && lastStockUpdatedAt !== null)
            url_ += "LastStockUpdatedAt=" + encodeURIComponent(lastStockUpdatedAt ? "" + formatDate(lastStockUpdatedAt) : "") + "&";
        if (offset !== undefined && offset !== null)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: AxiosResponse): Promise<PagedResultOfProductListItemDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfProductListItemDto.fromJS(resultData200);
            return Promise.resolve<PagedResultOfProductListItemDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfProductListItemDto>(null as any);
    }

    patch(id: number, dto: PatchProductDto , cancelToken?: CancelToken | undefined): Promise<ProductDto> {
        let url_ = this.baseUrl + "/api/products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPatch(_response);
        });
    }

    protected processPatch(response: AxiosResponse): Promise<ProductDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProductDto.fromJS(resultData200);
            return Promise.resolve<ProductDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProductDto>(null as any);
    }

    get(id: number , cancelToken?: CancelToken | undefined): Promise<ProductDto> {
        let url_ = this.baseUrl + "/api/products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ProductDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProductDto.fromJS(resultData200);
            return Promise.resolve<ProductDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProductDto>(null as any);
    }
}
type SearchProductQueryParameters = {
      search?: string | null | null;
      productType?: ProductType | null | null;
      lastStockUpdatedAt?: Date | null | null;
      offset?: number | null | null;
      limit?: number | null | null;
      sortBy?: string | null | null;
      sortOrder?: SortOrder | null;
};

type GetProductQueryParameters = {
      id: number;
};

export class ProductQuery{

    get baseUrl() {
      return getBaseUrl() ?? '' + '';
    }

    static get Client() {
        return createClient(ProductClient);
    }

    static get Url() {
        return new ProductQuery();
    }
    

    search(search?: string | null | undefined, productType?: ProductType | null | undefined, lastStockUpdatedAt?: Date | null | undefined, offset?: number | null | undefined, limit?: number | null | undefined, sortBy?: string | null | undefined, sortOrder?: SortOrder | undefined): string {
      let url_ = this.baseUrl + "/api/products?";
    if (search !== undefined && search !== null)
        url_ += "Search=" + encodeURIComponent("" + search) + "&";
    if (productType !== undefined && productType !== null)
        url_ += "ProductType=" + encodeURIComponent("" + productType) + "&";
    if (lastStockUpdatedAt !== undefined && lastStockUpdatedAt !== null)
        url_ += "LastStockUpdatedAt=" + encodeURIComponent(lastStockUpdatedAt ? "" + formatDate(lastStockUpdatedAt) : "") + "&";
    if (offset !== undefined && offset !== null)
        url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
    if (limit !== undefined && limit !== null)
        url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
    if (sortBy !== undefined && sortBy !== null)
        url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
    if (sortOrder === null)
        throw new Error("The parameter 'sortOrder' cannot be null.");
    else if (sortOrder !== undefined)
        url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&";
    url_ = url_.replace(/[?&]$/, "");
      return url_;
    }

    static searchDefaultOptions?: UseQueryOptions<PagedResultOfProductListItemDto, unknown, PagedResultOfProductListItemDto> = {};
    public static searchQueryKey(dto: SearchProductQueryParameters): QueryKey;
    public static searchQueryKey(search?: string | null | undefined,productType?: ProductType | null | undefined,lastStockUpdatedAt?: Date | null | undefined,offset?: number | null | undefined,limit?: number | null | undefined,sortBy?: string | null | undefined,sortOrder?: SortOrder | undefined): QueryKey;
    public static searchQueryKey(...params: any[]): QueryKey {
        if (params.length === 1 && isParameterObject(params[0])) {
            const { search, productType, lastStockUpdatedAt, offset, limit, sortBy, sortOrder,  } = params[0] as SearchProductQueryParameters;

            return removeUndefinedFromArrayTail([
                'ProductClient',
                'search',
                search as any,
                productType as any,
                lastStockUpdatedAt as any,
                offset as any,
                limit as any,
                sortBy as any,
                sortOrder as any,

            ]);
        } else {
            return removeUndefinedFromArrayTail([
                'ProductClient',
                'search',
                ...params
            ]);
        }
    }

    private static search(context: QueryFunctionContext) {
        return ProductQuery.Client.search(
                context.queryKey[2] as string | null | undefined, 
                context.queryKey[3] as ProductType | null | undefined, 
                context.queryKey[4] as Date | null | undefined, 
                context.queryKey[5] as number | null | undefined, 
                context.queryKey[6] as number | null | undefined, 
                context.queryKey[7] as string | null | undefined, 
                context.queryKey[8] as SortOrder | undefined
            );
    }

    static useSearchQuery<TSelectData = PagedResultOfProductListItemDto, TError = unknown>(dto: SearchProductQueryParameters, options?: UseQueryOptions<PagedResultOfProductListItemDto, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    /**
     * @param search (optional) 
     * @param productType (optional) 
     * @param lastStockUpdatedAt (optional) 
     * @param offset (optional) Offset of list.
     * @param limit (optional) Number of requested records.
     * @param sortBy (optional) Field name for sorting in DB.
     * @param sortOrder (optional) Sort direction. Ascending or Descending.
     */
    static useSearchQuery<TSelectData = PagedResultOfProductListItemDto, TError = unknown>(search?: string | null | undefined, productType?: ProductType | null | undefined, lastStockUpdatedAt?: Date | null | undefined, offset?: number | null | undefined, limit?: number | null | undefined, sortBy?: string | null | undefined, sortOrder?: SortOrder | undefined, options?: UseQueryOptions<PagedResultOfProductListItemDto, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    static useSearchQuery<TSelectData = PagedResultOfProductListItemDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {

        let options: UseQueryOptions<PagedResultOfProductListItemDto, TError, TSelectData> | undefined = undefined;
        let search: any = undefined;
        let productType: any = undefined;
        let lastStockUpdatedAt: any = undefined;
        let offset: any = undefined;
        let limit: any = undefined;
        let sortBy: any = undefined;
        let sortOrder: any = undefined;
        
        if (params.length > 0) {
            if (isParameterObject(params[0])) {
                ({ search, productType, lastStockUpdatedAt, offset, limit, sortBy, sortOrder,  } = params[0] as SearchProductQueryParameters);
                options = params[1];
            } else {
                [search, productType, lastStockUpdatedAt, offset, limit, sortBy, sortOrder,  options] = params;
            }
        }
    

        const metaContext = useContext(QueryMetaContext);
        options = addMetaToOptions(options, metaContext);

        return useQuery<PagedResultOfProductListItemDto, TError, TSelectData>({
            queryFn: ProductQuery.search,
            queryKey: ProductQuery.searchQueryKey(search, productType, lastStockUpdatedAt, offset, limit, sortBy, sortOrder),
            ...ProductQuery.searchDefaultOptions as unknown as UseQueryOptions<PagedResultOfProductListItemDto, TError, TSelectData>,
            ...options,
        });
    }
    /**
     * @param search (optional) 
     * @param productType (optional) 
     * @param lastStockUpdatedAt (optional) 
     * @param offset (optional) Offset of list.
     * @param limit (optional) Number of requested records.
     * @param sortBy (optional) Field name for sorting in DB.
     * @param sortOrder (optional) Sort direction. Ascending or Descending.
     */
    static setSearchData(queryClient: QueryClient, updater: (data: PagedResultOfProductListItemDto | undefined) => PagedResultOfProductListItemDto, search?: string | null | undefined, productType?: ProductType | null | undefined, lastStockUpdatedAt?: Date | null | undefined, offset?: number | null | undefined, limit?: number | null | undefined, sortBy?: string | null | undefined, sortOrder?: SortOrder | undefined) {
        queryClient.setQueryData(ProductQuery.searchQueryKey(search, productType, lastStockUpdatedAt, offset, limit, sortBy, sortOrder),
            updater
        );
    }

    /**
     * @param search (optional) 
     * @param productType (optional) 
     * @param lastStockUpdatedAt (optional) 
     * @param offset (optional) Offset of list.
     * @param limit (optional) Number of requested records.
     * @param sortBy (optional) Field name for sorting in DB.
     * @param sortOrder (optional) Sort direction. Ascending or Descending.
     */
    static setSearchDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: PagedResultOfProductListItemDto | undefined) => PagedResultOfProductListItemDto) {
        queryClient.setQueryData(queryKey, updater);
    }
      

    get(id: number): string {
      let url_ = this.baseUrl + "/api/products/{id}";
    if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");
      return url_;
    }

    static getDefaultOptions?: UseQueryOptions<ProductDto, unknown, ProductDto> = {};
    public static getQueryKey(id: number): QueryKey;
    public static getQueryKey(...params: any[]): QueryKey {
        if (params.length === 1 && isParameterObject(params[0])) {
            const { id,  } = params[0] as GetProductQueryParameters;

            return removeUndefinedFromArrayTail([
                'ProductClient',
                'get',
                id as any,

            ]);
        } else {
            return removeUndefinedFromArrayTail([
                'ProductClient',
                'get',
                ...params
            ]);
        }
    }

    private static get(context: QueryFunctionContext) {
        return ProductQuery.Client.get(
                context.queryKey[2] as number
            );
    }

    static useGetQuery<TSelectData = ProductDto, TError = unknown>(dto: GetProductQueryParameters, options?: UseQueryOptions<ProductDto, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    static useGetQuery<TSelectData = ProductDto, TError = unknown>(id: number, options?: UseQueryOptions<ProductDto, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    static useGetQuery<TSelectData = ProductDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {

        let options: UseQueryOptions<ProductDto, TError, TSelectData> | undefined = undefined;
        let id: any = undefined;
        
        if (params.length > 0) {
            if (isParameterObject(params[0])) {
                ({ id,  } = params[0] as GetProductQueryParameters);
                options = params[1];
            } else {
                [id,  options] = params;
            }
        }
    

        const metaContext = useContext(QueryMetaContext);
        options = addMetaToOptions(options, metaContext);

        return useQuery<ProductDto, TError, TSelectData>({
            queryFn: ProductQuery.get,
            queryKey: ProductQuery.getQueryKey(id),
            ...ProductQuery.getDefaultOptions as unknown as UseQueryOptions<ProductDto, TError, TSelectData>,
            ...options,
        });
    }
    static setGetData(queryClient: QueryClient, updater: (data: ProductDto | undefined) => ProductDto, id: number) {
        queryClient.setQueryData(ProductQuery.getQueryKey(id),
            updater
        );
    }

    static setGetDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: ProductDto | undefined) => ProductDto) {
        queryClient.setQueryData(queryKey, updater);
    }
    }
resultTypesByQueryKey['ProductClient___search'] = () => new PagedResultOfProductListItemDto();
resultTypesByQueryKey['ProductClient___get'] = () => new ProductDto();

export class SignUrlClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    getSignature(  cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/sign-url/signature";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSignature(_response);
        });
    }

    protected processGetSignature(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    setSignatureCookie(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/sign-url/signature/cookie";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetSignatureCookie(_response);
        });
    }

    protected processSetSignatureCookie(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}
export class SignUrlQuery{

    get baseUrl() {
      return getBaseUrl() ?? '' + '';
    }

    static get Client() {
        return createClient(SignUrlClient);
    }

    static get Url() {
        return new SignUrlQuery();
    }

    getSignature(): string {
      let url_ = this.baseUrl + "/api/sign-url/signature";
    url_ = url_.replace(/[?&]$/, "");
      return url_;
    }

    static getSignatureDefaultOptions?: UseQueryOptions<string, unknown, string> = {};
    public static getSignatureQueryKey(): QueryKey;
    public static getSignatureQueryKey(...params: any[]): QueryKey {
        return removeUndefinedFromArrayTail([
            'SignUrlClient',
            'getSignature',
            ]);
    }

    private static getSignature() {
        return SignUrlQuery.Client.getSignature(
            );
    }

    static useGetSignatureQuery<TSelectData = string, TError = unknown>(options?: UseQueryOptions<string, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    static useGetSignatureQuery<TSelectData = string, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {

        let options: UseQueryOptions<string, TError, TSelectData> | undefined = undefined;
        

        options = params[0] as any;
    

        const metaContext = useContext(QueryMetaContext);
        options = addMetaToOptions(options, metaContext);

        return useQuery<string, TError, TSelectData>({
            queryFn: SignUrlQuery.getSignature,
            queryKey: SignUrlQuery.getSignatureQueryKey(),
            ...SignUrlQuery.getSignatureDefaultOptions as unknown as UseQueryOptions<string, TError, TSelectData>,
            ...options,
        });
    }
    static setGetSignatureData(queryClient: QueryClient, updater: (data: string | undefined) => string, ) {
        queryClient.setQueryData(SignUrlQuery.getSignatureQueryKey(),
            updater
        );
    }

    static setGetSignatureDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: string | undefined) => string) {
        queryClient.setQueryData(queryKey, updater);
    }
    

    setSignatureCookie(): string {
      let url_ = this.baseUrl + "/api/sign-url/signature/cookie";
    url_ = url_.replace(/[?&]$/, "");
      return url_;
    }

    static setSignatureCookieDefaultOptions?: UseQueryOptions<void, unknown, void> = {};
    public static setSignatureCookieQueryKey(): QueryKey;
    public static setSignatureCookieQueryKey(...params: any[]): QueryKey {
        return removeUndefinedFromArrayTail([
            'SignUrlClient',
            'setSignatureCookie',
            ]);
    }

    private static setSignatureCookie() {
        return SignUrlQuery.Client.setSignatureCookie(
            );
    }

    static useSetSignatureCookieQuery<TSelectData = void, TError = unknown>(options?: UseQueryOptions<void, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    static useSetSignatureCookieQuery<TSelectData = void, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {

        let options: UseQueryOptions<void, TError, TSelectData> | undefined = undefined;
        

        options = params[0] as any;
    

        const metaContext = useContext(QueryMetaContext);
        options = addMetaToOptions(options, metaContext);

        return useQuery<void, TError, TSelectData>({
            queryFn: SignUrlQuery.setSignatureCookie,
            queryKey: SignUrlQuery.setSignatureCookieQueryKey(),
            ...SignUrlQuery.setSignatureCookieDefaultOptions as unknown as UseQueryOptions<void, TError, TSelectData>,
            ...options,
        });
    }
    static setSetSignatureCookieData(queryClient: QueryClient, updater: (data: void | undefined) => void, ) {
        queryClient.setQueryData(SignUrlQuery.setSignatureCookieQueryKey(),
            updater
        );
    }

    static setSetSignatureCookieDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: void | undefined) => void) {
        queryClient.setQueryData(queryKey, updater);
    }
    }

export class TestDataClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * Demonstrates an error response.
     */
    throwError(  cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/error-test";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processThrowError(_response);
        });
    }

    protected processThrowError(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Sends a dummy email
     */
    sendEmail(  cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/send-email";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendEmail(_response);
        });
    }

    protected processSendEmail(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Try this in browser with language set to DE
     * @param a (optional) 
     */
    formData(a?: number | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/formdata";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (a === null || a === undefined)
            throw new Error("The parameter 'a' cannot be null.");
        else
            content_.append("A", a.toString());

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFormData(_response);
        });
    }

    protected processFormData(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }
}
export class TestDataQuery{

    get baseUrl() {
      return getBaseUrl() ?? '' + '';
    }

    static get Client() {
        return createClient(TestDataClient);
    }

    static get Url() {
        return new TestDataQuery();
    }

    throwError(): string {
      let url_ = this.baseUrl + "/error-test";
    url_ = url_.replace(/[?&]$/, "");
      return url_;
    }

    static throwErrorDefaultOptions?: UseQueryOptions<string, unknown, string> = {};
    public static throwErrorQueryKey(): QueryKey;
    public static throwErrorQueryKey(...params: any[]): QueryKey {
        return removeUndefinedFromArrayTail([
            'TestDataClient',
            'throwError',
            ]);
    }

    private static throwError() {
        return TestDataQuery.Client.throwError(
            );
    }

    /**
     * Demonstrates an error response.
     */
    static useThrowErrorQuery<TSelectData = string, TError = unknown>(options?: UseQueryOptions<string, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    static useThrowErrorQuery<TSelectData = string, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {

        let options: UseQueryOptions<string, TError, TSelectData> | undefined = undefined;
        

        options = params[0] as any;
    

        const metaContext = useContext(QueryMetaContext);
        options = addMetaToOptions(options, metaContext);

        return useQuery<string, TError, TSelectData>({
            queryFn: TestDataQuery.throwError,
            queryKey: TestDataQuery.throwErrorQueryKey(),
            ...TestDataQuery.throwErrorDefaultOptions as unknown as UseQueryOptions<string, TError, TSelectData>,
            ...options,
        });
    }
    /**
     * Demonstrates an error response.
     */
    static setThrowErrorData(queryClient: QueryClient, updater: (data: string | undefined) => string, ) {
        queryClient.setQueryData(TestDataQuery.throwErrorQueryKey(),
            updater
        );
    }

    /**
     * Demonstrates an error response.
     */
    static setThrowErrorDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: string | undefined) => string) {
        queryClient.setQueryData(queryKey, updater);
    }
        }

export class VersionClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * Gets the version of the service.
     * @return A string representing the version.
     */
    version(  cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVersion(_response);
        });
    }

    protected processVersion(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }
}
export class VersionQuery{

    get baseUrl() {
      return getBaseUrl() ?? '' + '';
    }

    static get Client() {
        return createClient(VersionClient);
    }

    static get Url() {
        return new VersionQuery();
    }

    version(): string {
      let url_ = this.baseUrl + "/api";
    url_ = url_.replace(/[?&]$/, "");
      return url_;
    }

    static versionDefaultOptions?: UseQueryOptions<string, unknown, string> = {};
    public static versionQueryKey(): QueryKey;
    public static versionQueryKey(...params: any[]): QueryKey {
        return removeUndefinedFromArrayTail([
            'VersionClient',
            'version',
            ]);
    }

    private static version() {
        return VersionQuery.Client.version(
            );
    }

    /**
     * Gets the version of the service.
     * @return A string representing the version.
     */
    static useVersionQuery<TSelectData = string, TError = unknown>(options?: UseQueryOptions<string, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    static useVersionQuery<TSelectData = string, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {

        let options: UseQueryOptions<string, TError, TSelectData> | undefined = undefined;
        

        options = params[0] as any;
    

        const metaContext = useContext(QueryMetaContext);
        options = addMetaToOptions(options, metaContext);

        return useQuery<string, TError, TSelectData>({
            queryFn: VersionQuery.version,
            queryKey: VersionQuery.versionQueryKey(),
            ...VersionQuery.versionDefaultOptions as unknown as UseQueryOptions<string, TError, TSelectData>,
            ...options,
        });
    }
    /**
     * Gets the version of the service.
     * @return A string representing the version.
     */
    static setVersionData(queryClient: QueryClient, updater: (data: string | undefined) => string, ) {
        queryClient.setQueryData(VersionQuery.versionQueryKey(),
            updater
        );
    }

    /**
     * Gets the version of the service.
     * @return A string representing the version.
     */
    static setVersionDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: string | undefined) => string) {
        queryClient.setQueryData(queryKey, updater);
    }
    }

export class ProblemDetails implements IProblemDetails {
    type?: string | null;
    title?: string | null;
    status?: number | null;
    detail?: string | null;
    instance?: string | null;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | null;
    title?: string | null;
    status?: number | null;
    detail?: string | null;
    instance?: string | null;
    extensions?: { [key: string]: any; };
}

export class HttpValidationProblemDetails extends ProblemDetails implements IHttpValidationProblemDetails {
    errors?: { [key: string]: string[]; };

    constructor(data?: IHttpValidationProblemDetails) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): HttpValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new HttpValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IHttpValidationProblemDetails extends IProblemDetails {
    errors?: { [key: string]: string[]; };
}

export class ValidationProblemDetails extends HttpValidationProblemDetails implements IValidationProblemDetails {
    errors?: { [key: string]: string[]; };

    constructor(data?: IValidationProblemDetails) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): ValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IValidationProblemDetails extends IHttpValidationProblemDetails {
    errors?: { [key: string]: string[]; };
}

export class ProductDto implements IProductDto {
    id!: number;
    title!: string;
    productType!: ProductType;
    lastStockUpdatedAt!: Date;

    constructor(data?: IProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.productType = _data["productType"];
            this.lastStockUpdatedAt = _data["lastStockUpdatedAt"] ? parseDateOnly(_data["lastStockUpdatedAt"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): ProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["productType"] = this.productType;
        data["lastStockUpdatedAt"] = this.lastStockUpdatedAt && formatDate(this.lastStockUpdatedAt);
        return data;
    }
}

export interface IProductDto {
    id: number;
    title: string;
    productType: ProductType;
    lastStockUpdatedAt: Date;
}

export enum ProductType {
    Undefined = "Undefined",
    Auto = "Auto",
    Electronic = "Electronic",
    Other = "Other",
}

export class CreateProductDto implements ICreateProductDto {
    title!: string;
    productType!: ProductType;
    lastStockUpdatedAt!: Date;

    constructor(data?: ICreateProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.productType = _data["productType"];
            this.lastStockUpdatedAt = _data["lastStockUpdatedAt"] ? parseDateOnly(_data["lastStockUpdatedAt"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): CreateProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["productType"] = this.productType;
        data["lastStockUpdatedAt"] = this.lastStockUpdatedAt && formatDate(this.lastStockUpdatedAt);
        return data;
    }
}

export interface ICreateProductDto {
    title: string;
    productType: ProductType;
    lastStockUpdatedAt: Date;
}

export class PatchProductDto implements IPatchProductDto {
    title?: string;
    productType?: ProductType;
    lastStockUpdatedAt?: Date;

    constructor(data?: IPatchProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.productType = _data["productType"];
            this.lastStockUpdatedAt = _data["lastStockUpdatedAt"] ? parseDateOnly(_data["lastStockUpdatedAt"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): PatchProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new PatchProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["productType"] = this.productType;
        data["lastStockUpdatedAt"] = this.lastStockUpdatedAt && formatDate(this.lastStockUpdatedAt);
        return data;
    }
}

export interface IPatchProductDto {
    title?: string;
    productType?: ProductType;
    lastStockUpdatedAt?: Date;
}

export class PagedResultOfProductListItemDto implements IPagedResultOfProductListItemDto {
    data!: ProductListItemDto[];
    totalCount!: number;

    constructor(data?: IPagedResultOfProductListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ProductListItemDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultOfProductListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfProductListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultOfProductListItemDto {
    data: ProductListItemDto[];
    totalCount: number;
}

export class ProductListItemDto implements IProductListItemDto {
    id!: number;
    title!: string;
    productType!: ProductType;
    lastStockUpdatedAt!: Date;

    constructor(data?: IProductListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.productType = _data["productType"];
            this.lastStockUpdatedAt = _data["lastStockUpdatedAt"] ? parseDateOnly(_data["lastStockUpdatedAt"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): ProductListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["productType"] = this.productType;
        data["lastStockUpdatedAt"] = this.lastStockUpdatedAt && formatDate(this.lastStockUpdatedAt);
        return data;
    }
}

export interface IProductListItemDto {
    id: number;
    title: string;
    productType: ProductType;
    lastStockUpdatedAt: Date;
}

export enum SortOrder {
    Asc = "Asc",
    Desc = "Desc",
}

export function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

export function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

export function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}

import { addResultTypeFactory } from './api-client/helpers';
export { setBaseUrl } from './api-client/helpers';
export { setAxiosFactory, getAxios } from './api-client/helpers';


//-----PersistorHydrator.File-----
import type { PersistedClient } from '@tanstack/react-query-persist-client';
import type { QueryKey } from '@tanstack/react-query'
import { getResultTypeFactory } from './api-client/helpers';

/*
  Overrides default Client factory function
*/
export function setClientFactory(value: ClientFactoryFunction) {
  _clientFactoryFunction = value;
}

/*
  Returns current Client factory function
*/
export function getClientFactory() {
  return _clientFactoryFunction;
}

/*
  Function that will be called from `useQuery...` methods to get a client of certain type
*/
function createClient<T>(type: (new () => T)) {
  return _clientFactoryFunction(type);
}

let _baseUrl = '';
/*
  Returns the base URL for http requests
*/
export function getBaseUrl(): string {
  return _baseUrl;
}

/*
  Sets the base URL for http requests
*/
export function setBaseUrl(baseUrl: string) {
  _baseUrl = baseUrl;
}

let _axiosFactory: () => AxiosInstance | undefined = () => undefined;
/*
  Returns currently used factory for Axios instances
*/
export function getAxiosFactory() {
  return _axiosFactory;
}
/*
  Sets the factory for Axios instances
*/
export function setAxiosFactory(factory: () => AxiosInstance) {
  _axiosFactory = factory;
}

function addMetaToOptions<TResultType, TError, TSelectData>(options: UseQueryOptions<TResultType, TError, TSelectData> | undefined, metaContext: QueryMetaContextValue) {
  if (metaContext.metaFn) {
    options = options ?? { };
    options.meta = {
      ...metaContext.metaFn(),
      ...options.meta,
    };
  }
  return options;
}

function parseDateOnly(s: string) {
    const date = new Date(s);
    return new Date(date.getTime() +
        date.getTimezoneOffset() * 60000);
}
import type { PersistedClient } from '@tanstack/react-query-persist-client';
/*
 * If you have Dates in QueryKeys (i.e. in request parameters), you need to deserialize them to Dates correctly
 * (otherwise they are deserialized as strings by default, and your queries are broken).
 */
export function deserializeDate(str: unknown) {
  const date = new Date(str as string);
  const isDate = date instanceof Date && !isNaN(date as any) && date.toISOString() === str;
  return isDate ? date : str;
}

export function deserializeDatesInQueryKeys(client: PersistedClient) {
  client.clientState.queries.forEach((query) => {
    const data: any = query.state.data;
    query.queryKey = query.queryKey.map(x => deserializeDate(x));
  });
}

export function deserializeClassesInQueryData(client: PersistedClient) {
  client.clientState.queries.forEach((query) => {
    const data: any = query.state.data;
    if (Array.isArray(data)) {
      query.state.data = data.map(elem => constructDtoClass(query.queryKey, elem));
    } else {
      query.state.data = constructDtoClass(query.queryKey, data);
    }
  });
}
/*
 * Pass this function as `deserialize` option to createSyncStoragePersister/createAsyncStoragePersister
 * to correctly deserialize your DTOs (including Dates)
 */
export function persistorDeserialize(cache: string): PersistedClient {
  const client: PersistedClient = JSON.parse(cache);
  deserializeClassesInQueryData(client);
  deserializeDatesInQueryKeys(client);

  return client;
}

export function constructDtoClass(queryKey: QueryKey, data: any): unknown {
  const resultTypeKey = getResultTypeClassKey(queryKey);
  const constructorFunction = getResultTypeFactory(resultTypeKey);

  if (!data || !constructorFunction)
    return data;

  const dto = constructorFunction();
  dto.init(data);

  return dto;
}

export function getResultTypeClassKey(queryKey: QueryKey): string {
  if (!Array.isArray(queryKey)) {
    return queryKey as unknown as string;
  }
  if (queryKey.length >= 2) {
    // We concatenate first and second elements, because they uniquely identify the query.
    // All other QueryKey elements are query parameters
    return `${queryKey[0]}___${queryKey[1]}`;
  }

  // We actually should never reach this point :)
  return queryKey.join('___');
}

export function initPersistor() {
  
  addResultTypeFactory('ProductClient___search', () => new PagedResultOfProductListItemDto());
  addResultTypeFactory('ProductClient___get', () => new ProductDto());








}
//-----/PersistorHydrator.File----